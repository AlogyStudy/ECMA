<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  
  <script>

    // 堆内存
    // 存放引用内存的属性值
    // 如何释放堆内存
    // null空对象指针

    // 对象数据类型或者函数数据类型在定义的时候首先都会开辟一个堆内存，
    // 堆内存有一个引用的地址，如果外边有变量知道了这个地址，这个内存就被占用，不能销毁。

    // var obj1 = {name: 1};
    // var obj2 = obj1;

    // // 想让堆内存释放/销毁，只需要把所有的引用它的变量赋值为null即可。如果堆内存没有任何东西被占用了，那么浏览器会在空闲的时候，会把它销毁。
    // // 垃圾回收
    // obj1 = null;
    // obj2 = null;


    // 栈内存
    // 存放作用域
    // 全局作用域(浏览器天然开辟，浏览器关闭的时候才释放)，
    // 私有作用域（只有函数执行，才会产生私有做作用域）
    // 一般情况下，函数执行会形成一个新的私有的作用域，当私有作用域中的代码执行完成后，当前作用域都会主动进行释放和销毁。
    // 作用域有被子级作用域引用，父级的私有变量不能销毁。
    // 1. 函数执行返回了一个引用数据类型值，并且在函数外边一个变量接收，这种情况下一般形成的私有作用域都不能被销毁。
    // 2. 在一个私有的作用域中，给DOM元素的事件绑定方法，一般情况下，私有作用域都不会销毁。（ DOM对象，在执行性函数中被引用）


    // 1: 引用类型的返回值，被外界引用
    // function fn() {
    //   var num = 10;
    //   return function() {

    //   }
    // }
    // var f = fn();

    

    // 2:  DOM对象，在执行性函数中被引用
    // var oDiv = document.getElementById('div1');
    // ~function() {
    //   oDiv.onclick = function() {}
    // }(); // 当自执行函数形成的这个私有作用域也不销毁



    // 3: 返回的回调函数再次被执行，不会被立即销毁内存  (不立即销毁)
    function fn() {
      var num = 10;
      return function() {

      }
    }
    fn()(); // 首先fn执行，返回一个回调函数对应的内存地址，然后紧接着让返回的小函数再执行。
    // 返回的回调函数再次被执行，不会被立即销毁内存，当返回的回调函数执行完成后，浏览器会在空闲的时候销毁。

  </script>

</body>
</html>